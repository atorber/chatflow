'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.commandFactory = exports.INPUT_STRING_ERROR = exports.INPUT_JSON_UNDEFINED_ERROR = exports.FILTER_UNDEFINED_ERROR = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _joi = require('@hapi/joi');

var Joi = _interopRequireWildcard(_joi);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _options = require('./options');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var JQ_PATH = process.env.JQ_PATH || _path2.default.join(__dirname, '..', 'bin', 'jq');

var FILTER_UNDEFINED_ERROR = exports.FILTER_UNDEFINED_ERROR = 'node-jq: invalid filter argument supplied: "undefined"';
var INPUT_JSON_UNDEFINED_ERROR = exports.INPUT_JSON_UNDEFINED_ERROR = 'node-jq: invalid json object argument supplied: "undefined"';
var INPUT_STRING_ERROR = exports.INPUT_STRING_ERROR = 'node-jq: invalid json string argument supplied';

var NODE_JQ_ERROR_TEMPLATE = 'node-jq: invalid {#label} ' + 'argument supplied{if(#label == "path" && #type == "json", " (not a .json file)", "")}' + '{if(#label == "path" && #type == "path", " (not a valid path)", "")}: ' + '"{if(#value != undefined, #value, "undefined")}"';

var messages = {
  'any.invalid': NODE_JQ_ERROR_TEMPLATE,
  'any.required': NODE_JQ_ERROR_TEMPLATE,
  'string.base': NODE_JQ_ERROR_TEMPLATE,
  'string.empty': NODE_JQ_ERROR_TEMPLATE
};

var validateArguments = function validateArguments(filter, json, options) {
  var context = { filter: filter, json: json };
  var validatedOptions = Joi.attempt(options, _options.optionsSchema);
  var validatedPreSpawn = Joi.attempt(context, _options.preSpawnSchema.tailor(validatedOptions.input), { messages: messages });
  var validatedArgs = (0, _options.parseOptions)(validatedOptions, validatedPreSpawn.filter, validatedPreSpawn.json);
  var validatedSpawn = Joi.attempt({}, _options.spawnSchema.tailor(validatedOptions.input), { context: _extends({}, validatedPreSpawn, { options: validatedOptions }) });

  if (validatedOptions.input === 'file') {
    return {
      args: validatedArgs,
      stdin: validatedSpawn.stdin
    };
  }
  return {
    args: validatedArgs,
    stdin: validatedSpawn.stdin
  };
};

var commandFactory = exports.commandFactory = function commandFactory(filter, json) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var jqPath = arguments[3];

  var command = jqPath ? _path2.default.join(jqPath, './jq') : JQ_PATH;
  var result = validateArguments(filter, json, options);

  return {
    command: command,
    args: result.args,
    stdin: result.stdin
  };
};